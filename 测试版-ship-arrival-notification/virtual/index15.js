import { Chart as Chart$1, PieController, LineController } from './chart.js';
import {
  defineComponent,
  h,
  version,
  onMounted,
  onUnmounted,
  watch,
  nextTick,
} from './runtime-core.esm-bundler.js';
import { shallowRef, ref, toRaw, isProxy } from './reactivity.esm-bundler.js';
const CommonProps = {
  data: {
    type: Object,
    required: true,
  },
  options: {
    type: Object,
    default: () => ({}),
  },
  plugins: {
    type: Array,
    default: () => [],
  },
  datasetIdKey: {
    type: String,
    default: 'label',
  },
  updateMode: {
    type: String,
    default: void 0,
  },
};
const A11yProps = {
  ariaLabel: {
    type: String,
  },
  ariaDescribedby: {
    type: String,
  },
};
const Props = {
  type: {
    type: String,
    required: true,
  },
  destroyDelay: {
    type: Number,
    default: 0,
    // No delay by default
  },
  ...CommonProps,
  ...A11yProps,
};
const compatProps =
  version[0] === '2'
    ? (internals, props) =>
        Object.assign(internals, {
          attrs: props,
        })
    : (internals, props) => Object.assign(internals, props);
function toRawIfProxy(obj) {
  return isProxy(obj) ? toRaw(obj) : obj;
}
function cloneProxy(obj) {
  let src = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : obj;
  return isProxy(src) ? new Proxy(obj, {}) : obj;
}
function setOptions(chart, nextOptions) {
  const options = chart.options;
  if (options && nextOptions) {
    Object.assign(options, nextOptions);
  }
}
function setLabels(currentData, nextLabels) {
  currentData.labels = nextLabels;
}
function setDatasets(currentData, nextDatasets, datasetIdKey) {
  const addedDatasets = [];
  currentData.datasets = nextDatasets.map(nextDataset => {
    const currentDataset = currentData.datasets.find(
      dataset => dataset[datasetIdKey] === nextDataset[datasetIdKey],
    );
    if (!currentDataset || !nextDataset.data || addedDatasets.includes(currentDataset)) {
      return {
        ...nextDataset,
      };
    }
    addedDatasets.push(currentDataset);
    Object.assign(currentDataset, nextDataset);
    return currentDataset;
  });
}
function cloneData(data, datasetIdKey) {
  const nextData = {
    labels: [],
    datasets: [],
  };
  setLabels(nextData, data.labels);
  setDatasets(nextData, data.datasets, datasetIdKey);
  return nextData;
}
const Chart = defineComponent({
  props: Props,
  setup(props, param) {
    let { expose, slots } = param;
    const canvasRef = ref(null);
    const chartRef = shallowRef(null);
    expose({
      chart: chartRef,
    });
    const renderChart = () => {
      if (!canvasRef.value) return;
      const { type, data, options, plugins, datasetIdKey } = props;
      const clonedData = cloneData(data, datasetIdKey);
      const proxiedData = cloneProxy(clonedData, data);
      chartRef.value = new Chart$1(canvasRef.value, {
        type,
        data: proxiedData,
        options: {
          ...options,
        },
        plugins,
      });
    };
    const destroyChart = () => {
      const chart = toRaw(chartRef.value);
      if (chart) {
        if (props.destroyDelay > 0) {
          setTimeout(() => {
            chart.destroy();
            chartRef.value = null;
          }, props.destroyDelay);
        } else {
          chart.destroy();
          chartRef.value = null;
        }
      }
    };
    const update = chart => {
      chart.update(props.updateMode);
    };
    onMounted(renderChart);
    onUnmounted(destroyChart);
    watch(
      [() => props.options, () => props.data],
      (param2, param1) => {
        let [nextOptionsProxy, nextDataProxy] = param2,
          [prevOptionsProxy, prevDataProxy] = param1;
        const chart = toRaw(chartRef.value);
        if (!chart) {
          return;
        }
        let shouldUpdate = false;
        if (nextOptionsProxy) {
          const nextOptions = toRawIfProxy(nextOptionsProxy);
          const prevOptions = toRawIfProxy(prevOptionsProxy);
          if (nextOptions && nextOptions !== prevOptions) {
            setOptions(chart, nextOptions);
            shouldUpdate = true;
          }
        }
        if (nextDataProxy) {
          const nextLabels = toRawIfProxy(nextDataProxy.labels);
          const prevLabels = toRawIfProxy(prevDataProxy.labels);
          const nextDatasets = toRawIfProxy(nextDataProxy.datasets);
          const prevDatasets = toRawIfProxy(prevDataProxy.datasets);
          if (nextLabels !== prevLabels) {
            setLabels(chart.config.data, nextLabels);
            shouldUpdate = true;
          }
          if (nextDatasets && nextDatasets !== prevDatasets) {
            setDatasets(chart.config.data, nextDatasets, props.datasetIdKey);
            shouldUpdate = true;
          }
        }
        if (shouldUpdate) {
          nextTick(() => {
            update(chart);
          });
        }
      },
      {
        deep: true,
      },
    );
    return () => {
      return h(
        'canvas',
        {
          role: 'img',
          ariaLabel: props.ariaLabel,
          ariaDescribedby: props.ariaDescribedby,
          ref: canvasRef,
        },
        [h('p', {}, [slots.default ? slots.default() : ''])],
      );
    };
  },
});
function createTypedChart(type, registerables) {
  Chart$1.register(registerables);
  return defineComponent({
    props: CommonProps,
    setup(props, param) {
      let { expose } = param;
      const ref2 = shallowRef(null);
      const reforwardRef = chartRef => {
        ref2.value = chartRef?.chart;
      };
      expose({
        chart: ref2,
      });
      return () => {
        return h(
          Chart,
          compatProps(
            {
              ref: reforwardRef,
            },
            {
              type,
              ...props,
            },
          ),
        );
      };
    },
  });
}
const Line = /* @__PURE__ */ createTypedChart('line', LineController);
const Pie = /* @__PURE__ */ createTypedChart('pie', PieController);
export { Chart, Line, Pie, createTypedChart };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXgxNS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3Z1ZS1jaGFydGpzQDUuMy4yX2NoYXJ0LmpzQDQuNS4wX3Z1ZUAzLjUuMjBfdHlwZXNjcmlwdEA1LjkuMl8vbm9kZV9tb2R1bGVzL3Z1ZS1jaGFydGpzL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2hhcnQgYXMgQ2hhcnQkMSwgQmFyQ29udHJvbGxlciwgRG91Z2hudXRDb250cm9sbGVyLCBMaW5lQ29udHJvbGxlciwgUGllQ29udHJvbGxlciwgUG9sYXJBcmVhQ29udHJvbGxlciwgUmFkYXJDb250cm9sbGVyLCBCdWJibGVDb250cm9sbGVyLCBTY2F0dGVyQ29udHJvbGxlciB9IGZyb20gJ2NoYXJ0LmpzJztcbmltcG9ydCB7IHZlcnNpb24sIGlzUHJveHksIHRvUmF3LCBkZWZpbmVDb21wb25lbnQsIHJlZiwgc2hhbGxvd1JlZiwgb25Nb3VudGVkLCBvblVubW91bnRlZCwgd2F0Y2gsIG5leHRUaWNrLCBoIH0gZnJvbSAndnVlJztcblxuY29uc3QgQ29tbW9uUHJvcHMgPSB7XG4gICAgZGF0YToge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgZGVmYXVsdDogKCk9Pih7fSlcbiAgICB9LFxuICAgIHBsdWdpbnM6IHtcbiAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgIGRlZmF1bHQ6ICgpPT5bXVxuICAgIH0sXG4gICAgZGF0YXNldElkS2V5OiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogXCJsYWJlbFwiXG4gICAgfSxcbiAgICB1cGRhdGVNb2RlOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogdW5kZWZpbmVkXG4gICAgfVxufTtcbmNvbnN0IEExMXlQcm9wcyA9IHtcbiAgICBhcmlhTGFiZWw6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcbiAgICBhcmlhRGVzY3JpYmVkYnk6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgfVxufTtcbmNvbnN0IFByb3BzID0ge1xuICAgIHR5cGU6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAgZGVzdHJveURlbGF5OiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgZGVmYXVsdDogMCAvLyBObyBkZWxheSBieSBkZWZhdWx0XG4gICAgfSxcbiAgICAuLi5Db21tb25Qcm9wcyxcbiAgICAuLi5BMTF5UHJvcHNcbn07XG5cbmNvbnN0IGNvbXBhdFByb3BzID0gdmVyc2lvblswXSA9PT0gXCIyXCIgPyAoaW50ZXJuYWxzLCBwcm9wcyk9Pk9iamVjdC5hc3NpZ24oaW50ZXJuYWxzLCB7XG4gICAgICAgIGF0dHJzOiBwcm9wc1xuICAgIH0pIDogKGludGVybmFscywgcHJvcHMpPT5PYmplY3QuYXNzaWduKGludGVybmFscywgcHJvcHMpO1xuZnVuY3Rpb24gdG9SYXdJZlByb3h5KG9iaikge1xuICAgIHJldHVybiBpc1Byb3h5KG9iaikgPyB0b1JhdyhvYmopIDogb2JqO1xufVxuZnVuY3Rpb24gY2xvbmVQcm94eShvYmopIHtcbiAgICBsZXQgc3JjID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiBvYmo7XG4gICAgcmV0dXJuIGlzUHJveHkoc3JjKSA/IG5ldyBQcm94eShvYmosIHt9KSA6IG9iajtcbn1cbmZ1bmN0aW9uIHNldE9wdGlvbnMoY2hhcnQsIG5leHRPcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnM7XG4gICAgaWYgKG9wdGlvbnMgJiYgbmV4dE9wdGlvbnMpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCBuZXh0T3B0aW9ucyk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0TGFiZWxzKGN1cnJlbnREYXRhLCBuZXh0TGFiZWxzKSB7XG4gICAgY3VycmVudERhdGEubGFiZWxzID0gbmV4dExhYmVscztcbn1cbmZ1bmN0aW9uIHNldERhdGFzZXRzKGN1cnJlbnREYXRhLCBuZXh0RGF0YXNldHMsIGRhdGFzZXRJZEtleSkge1xuICAgIGNvbnN0IGFkZGVkRGF0YXNldHMgPSBbXTtcbiAgICBjdXJyZW50RGF0YS5kYXRhc2V0cyA9IG5leHREYXRhc2V0cy5tYXAoKG5leHREYXRhc2V0KT0+e1xuICAgICAgICAvLyBnaXZlbiB0aGUgbmV3IHNldCwgZmluZCBpdCdzIGN1cnJlbnQgbWF0Y2hcbiAgICAgICAgY29uc3QgY3VycmVudERhdGFzZXQgPSBjdXJyZW50RGF0YS5kYXRhc2V0cy5maW5kKChkYXRhc2V0KT0+ZGF0YXNldFtkYXRhc2V0SWRLZXldID09PSBuZXh0RGF0YXNldFtkYXRhc2V0SWRLZXldKTtcbiAgICAgICAgLy8gVGhlcmUgaXMgbm8gb3JpZ2luYWwgdG8gdXBkYXRlLCBzbyBzaW1wbHkgYWRkIG5ldyBvbmVcbiAgICAgICAgaWYgKCFjdXJyZW50RGF0YXNldCB8fCAhbmV4dERhdGFzZXQuZGF0YSB8fCBhZGRlZERhdGFzZXRzLmluY2x1ZGVzKGN1cnJlbnREYXRhc2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5uZXh0RGF0YXNldFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBhZGRlZERhdGFzZXRzLnB1c2goY3VycmVudERhdGFzZXQpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGN1cnJlbnREYXRhc2V0LCBuZXh0RGF0YXNldCk7XG4gICAgICAgIHJldHVybiBjdXJyZW50RGF0YXNldDtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNsb25lRGF0YShkYXRhLCBkYXRhc2V0SWRLZXkpIHtcbiAgICBjb25zdCBuZXh0RGF0YSA9IHtcbiAgICAgICAgbGFiZWxzOiBbXSxcbiAgICAgICAgZGF0YXNldHM6IFtdXG4gICAgfTtcbiAgICBzZXRMYWJlbHMobmV4dERhdGEsIGRhdGEubGFiZWxzKTtcbiAgICBzZXREYXRhc2V0cyhuZXh0RGF0YSwgZGF0YS5kYXRhc2V0cywgZGF0YXNldElkS2V5KTtcbiAgICByZXR1cm4gbmV4dERhdGE7XG59XG4vKipcbiAqIEdldCBkYXRhc2V0IGZyb20gbW91c2UgY2xpY2sgZXZlbnRcbiAqIEBwYXJhbSBjaGFydCAtIENoYXJ0LmpzIGluc3RhbmNlXG4gKiBAcGFyYW0gZXZlbnQgLSBNb3VzZSBjbGljayBldmVudFxuICogQHJldHVybnMgRGF0YXNldFxuICovIGZ1bmN0aW9uIGdldERhdGFzZXRBdEV2ZW50KGNoYXJ0LCBldmVudCkge1xuICAgIHJldHVybiBjaGFydC5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGV2ZW50LCBcImRhdGFzZXRcIiwge1xuICAgICAgICBpbnRlcnNlY3Q6IHRydWVcbiAgICB9LCBmYWxzZSk7XG59XG4vKipcbiAqIEdldCBzaW5nbGUgZGF0YXNldCBlbGVtZW50IGZyb20gbW91c2UgY2xpY2sgZXZlbnRcbiAqIEBwYXJhbSBjaGFydCAtIENoYXJ0LmpzIGluc3RhbmNlXG4gKiBAcGFyYW0gZXZlbnQgLSBNb3VzZSBjbGljayBldmVudFxuICogQHJldHVybnMgRGF0YXNldFxuICovIGZ1bmN0aW9uIGdldEVsZW1lbnRBdEV2ZW50KGNoYXJ0LCBldmVudCkge1xuICAgIHJldHVybiBjaGFydC5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGV2ZW50LCBcIm5lYXJlc3RcIiwge1xuICAgICAgICBpbnRlcnNlY3Q6IHRydWVcbiAgICB9LCBmYWxzZSk7XG59XG4vKipcbiAqIEdldCBhbGwgZGF0YXNldCBlbGVtZW50cyBmcm9tIG1vdXNlIGNsaWNrIGV2ZW50XG4gKiBAcGFyYW0gY2hhcnQgLSBDaGFydC5qcyBpbnN0YW5jZVxuICogQHBhcmFtIGV2ZW50IC0gTW91c2UgY2xpY2sgZXZlbnRcbiAqIEByZXR1cm5zIERhdGFzZXRcbiAqLyBmdW5jdGlvbiBnZXRFbGVtZW50c0F0RXZlbnQoY2hhcnQsIGV2ZW50KSB7XG4gICAgcmV0dXJuIGNoYXJ0LmdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZXZlbnQsIFwiaW5kZXhcIiwge1xuICAgICAgICBpbnRlcnNlY3Q6IHRydWVcbiAgICB9LCBmYWxzZSk7XG59XG5cbmNvbnN0IENoYXJ0ID0gZGVmaW5lQ29tcG9uZW50KHtcbiAgICBwcm9wczogUHJvcHMsXG4gICAgc2V0dXAgKHByb3BzLCBwYXJhbSkge1xuICAgICAgICBsZXQgeyBleHBvc2UgLCBzbG90cyAgfSA9IHBhcmFtO1xuICAgICAgICBjb25zdCBjYW52YXNSZWYgPSByZWYobnVsbCk7XG4gICAgICAgIGNvbnN0IGNoYXJ0UmVmID0gc2hhbGxvd1JlZihudWxsKTtcbiAgICAgICAgZXhwb3NlKHtcbiAgICAgICAgICAgIGNoYXJ0OiBjaGFydFJlZlxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVuZGVyQ2hhcnQgPSAoKT0+e1xuICAgICAgICAgICAgaWYgKCFjYW52YXNSZWYudmFsdWUpIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZSAsIGRhdGEgLCBvcHRpb25zICwgcGx1Z2lucyAsIGRhdGFzZXRJZEtleSAgfSA9IHByb3BzO1xuICAgICAgICAgICAgY29uc3QgY2xvbmVkRGF0YSA9IGNsb25lRGF0YShkYXRhLCBkYXRhc2V0SWRLZXkpO1xuICAgICAgICAgICAgY29uc3QgcHJveGllZERhdGEgPSBjbG9uZVByb3h5KGNsb25lZERhdGEsIGRhdGEpO1xuICAgICAgICAgICAgY2hhcnRSZWYudmFsdWUgPSBuZXcgQ2hhcnQkMShjYW52YXNSZWYudmFsdWUsIHtcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIGRhdGE6IHByb3hpZWREYXRhLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcGx1Z2luc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGRlc3Ryb3lDaGFydCA9ICgpPT57XG4gICAgICAgICAgICBjb25zdCBjaGFydCA9IHRvUmF3KGNoYXJ0UmVmLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjaGFydCkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wcy5kZXN0cm95RGVsYXkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0UmVmLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfSwgcHJvcHMuZGVzdHJveURlbGF5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGFydC5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0UmVmLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHVwZGF0ZSA9IChjaGFydCk9PntcbiAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZShwcm9wcy51cGRhdGVNb2RlKTtcbiAgICAgICAgfTtcbiAgICAgICAgb25Nb3VudGVkKHJlbmRlckNoYXJ0KTtcbiAgICAgICAgb25Vbm1vdW50ZWQoZGVzdHJveUNoYXJ0KTtcbiAgICAgICAgd2F0Y2goW1xuICAgICAgICAgICAgKCk9PnByb3BzLm9wdGlvbnMsXG4gICAgICAgICAgICAoKT0+cHJvcHMuZGF0YVxuICAgICAgICBdLCAocGFyYW0sIHBhcmFtMSk9PntcbiAgICAgICAgICAgIGxldCBbbmV4dE9wdGlvbnNQcm94eSwgbmV4dERhdGFQcm94eV0gPSBwYXJhbSwgW3ByZXZPcHRpb25zUHJveHksIHByZXZEYXRhUHJveHldID0gcGFyYW0xO1xuICAgICAgICAgICAgY29uc3QgY2hhcnQgPSB0b1JhdyhjaGFydFJlZi52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoIWNoYXJ0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNob3VsZFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG5leHRPcHRpb25zUHJveHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0T3B0aW9ucyA9IHRvUmF3SWZQcm94eShuZXh0T3B0aW9uc1Byb3h5KTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2T3B0aW9ucyA9IHRvUmF3SWZQcm94eShwcmV2T3B0aW9uc1Byb3h5KTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dE9wdGlvbnMgJiYgbmV4dE9wdGlvbnMgIT09IHByZXZPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldE9wdGlvbnMoY2hhcnQsIG5leHRPcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dERhdGFQcm94eSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRMYWJlbHMgPSB0b1Jhd0lmUHJveHkobmV4dERhdGFQcm94eS5sYWJlbHMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZMYWJlbHMgPSB0b1Jhd0lmUHJveHkocHJldkRhdGFQcm94eS5sYWJlbHMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHREYXRhc2V0cyA9IHRvUmF3SWZQcm94eShuZXh0RGF0YVByb3h5LmRhdGFzZXRzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2RGF0YXNldHMgPSB0b1Jhd0lmUHJveHkocHJldkRhdGFQcm94eS5kYXRhc2V0cyk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRMYWJlbHMgIT09IHByZXZMYWJlbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0TGFiZWxzKGNoYXJ0LmNvbmZpZy5kYXRhLCBuZXh0TGFiZWxzKTtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHREYXRhc2V0cyAmJiBuZXh0RGF0YXNldHMgIT09IHByZXZEYXRhc2V0cykge1xuICAgICAgICAgICAgICAgICAgICBzZXREYXRhc2V0cyhjaGFydC5jb25maWcuZGF0YSwgbmV4dERhdGFzZXRzLCBwcm9wcy5kYXRhc2V0SWRLZXkpO1xuICAgICAgICAgICAgICAgICAgICBzaG91bGRVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICBuZXh0VGljaygoKT0+e1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGUoY2hhcnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBkZWVwOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIHJldHVybiBoKFwiY2FudmFzXCIsIHtcbiAgICAgICAgICAgICAgICByb2xlOiBcImltZ1wiLFxuICAgICAgICAgICAgICAgIGFyaWFMYWJlbDogcHJvcHMuYXJpYUxhYmVsLFxuICAgICAgICAgICAgICAgIGFyaWFEZXNjcmliZWRieTogcHJvcHMuYXJpYURlc2NyaWJlZGJ5LFxuICAgICAgICAgICAgICAgIHJlZjogY2FudmFzUmVmXG4gICAgICAgICAgICB9LCBbXG4gICAgICAgICAgICAgICAgaChcInBcIiwge30sIFtcbiAgICAgICAgICAgICAgICAgICAgc2xvdHMuZGVmYXVsdCA/IHNsb3RzLmRlZmF1bHQoKSA6IFwiXCJcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVR5cGVkQ2hhcnQodHlwZSwgcmVnaXN0ZXJhYmxlcykge1xuICAgIENoYXJ0JDEucmVnaXN0ZXIocmVnaXN0ZXJhYmxlcyk7XG4gICAgcmV0dXJuIGRlZmluZUNvbXBvbmVudCh7XG4gICAgICAgIHByb3BzOiBDb21tb25Qcm9wcyxcbiAgICAgICAgc2V0dXAgKHByb3BzLCBwYXJhbSkge1xuICAgICAgICAgICAgbGV0IHsgZXhwb3NlICB9ID0gcGFyYW07XG4gICAgICAgICAgICBjb25zdCByZWYgPSBzaGFsbG93UmVmKG51bGwpO1xuICAgICAgICAgICAgY29uc3QgcmVmb3J3YXJkUmVmID0gKGNoYXJ0UmVmKT0+e1xuICAgICAgICAgICAgICAgIHJlZi52YWx1ZSA9IGNoYXJ0UmVmPy5jaGFydDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvc2Uoe1xuICAgICAgICAgICAgICAgIGNoYXJ0OiByZWZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICAgICAgcmV0dXJuIGgoQ2hhcnQsIGNvbXBhdFByb3BzKHtcbiAgICAgICAgICAgICAgICAgICAgcmVmOiByZWZvcndhcmRSZWZcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIC4uLnByb3BzXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuY29uc3QgQmFyID0gLyogI19fUFVSRV9fICovIGNyZWF0ZVR5cGVkQ2hhcnQoXCJiYXJcIiwgQmFyQ29udHJvbGxlcik7XG5jb25zdCBEb3VnaG51dCA9IC8qICNfX1BVUkVfXyAqLyBjcmVhdGVUeXBlZENoYXJ0KFwiZG91Z2hudXRcIiwgRG91Z2hudXRDb250cm9sbGVyKTtcbmNvbnN0IExpbmUgPSAvKiAjX19QVVJFX18gKi8gY3JlYXRlVHlwZWRDaGFydChcImxpbmVcIiwgTGluZUNvbnRyb2xsZXIpO1xuY29uc3QgUGllID0gLyogI19fUFVSRV9fICovIGNyZWF0ZVR5cGVkQ2hhcnQoXCJwaWVcIiwgUGllQ29udHJvbGxlcik7XG5jb25zdCBQb2xhckFyZWEgPSAvKiAjX19QVVJFX18gKi8gY3JlYXRlVHlwZWRDaGFydChcInBvbGFyQXJlYVwiLCBQb2xhckFyZWFDb250cm9sbGVyKTtcbmNvbnN0IFJhZGFyID0gLyogI19fUFVSRV9fICovIGNyZWF0ZVR5cGVkQ2hhcnQoXCJyYWRhclwiLCBSYWRhckNvbnRyb2xsZXIpO1xuY29uc3QgQnViYmxlID0gLyogI19fUFVSRV9fICovIGNyZWF0ZVR5cGVkQ2hhcnQoXCJidWJibGVcIiwgQnViYmxlQ29udHJvbGxlcik7XG5jb25zdCBTY2F0dGVyID0gLyogI19fUFVSRV9fICovIGNyZWF0ZVR5cGVkQ2hhcnQoXCJzY2F0dGVyXCIsIFNjYXR0ZXJDb250cm9sbGVyKTtcblxuZXhwb3J0IHsgQmFyLCBCdWJibGUsIENoYXJ0LCBEb3VnaG51dCwgTGluZSwgUGllLCBQb2xhckFyZWEsIFJhZGFyLCBTY2F0dGVyLCBjcmVhdGVUeXBlZENoYXJ0LCBnZXREYXRhc2V0QXRFdmVudCwgZ2V0RWxlbWVudEF0RXZlbnQsIGdldEVsZW1lbnRzQXRFdmVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsicGFyYW0iLCJyZWYiXSwibWFwcGluZ3MiOiI7OztBQUdBLE1BQU0sY0FBYztBQUFBLEVBQ2hCLE1BQU07QUFBQSxJQUNGLE1BQU07QUFBQSxJQUNOLFVBQVU7QUFBQSxFQUNsQjtBQUFBLEVBQ0ksU0FBUztBQUFBLElBQ0wsTUFBTTtBQUFBLElBQ04sU0FBUyxP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QUksZUFBZTtBQUNmLGNBQU0sYUFBYSxhQUFhLGNBQWMsTUFBTTtBQUNwRCxjQUFNLGFBQWEsYUFBYSxjQUFjLE1BQU07QUFDcEQsY0FBTSxlQUFlLGFBQWEsY0FBYyxRQUFRO0FBQ3hELGNBQU0sZUFBZSxhQUFhLGNBQWMsUUFBUTtBQUN4RCxZQUFJLGVBQWUsWUFBWTtBQUMzQixvQkFBVSxNQUFNLE9BQU8sTUFBTSxVQUFVO0FBQ3ZDLHlCQUFlO0FBQUEsUUFDbkI7QUFDQSxZQUFJLGdCQUFnQixpQkFBaUIsY0FBYztBQUMvQyxzQkFBWSxNQUFNLE9BQU8sTUFBTSxjQUFjLE1BQU0sWUFBWTtBQUMvRCx5QkFBZTtBQUFBLFFBQ25CO0FBQUEsTUFDSjtBQUNBLFVBQUksY0FBYztBQUNkLGlCQUFTLE1BQUk7QUFDVCxpQkFBTyxLQUFLO0FBQUEsUUFDaEIsQ0FBQztBQUFBLE1BQ0w7QUFBQSxJQUNKLEdBQUc7QUFBQSxNQUNDLE1BQU07QUFBQSxJQUNsQixDQUFTO0FBQ0QsV0FBTyxNQUFJO0FBQ1AsYUFBTyxFQUFFLFVBQVU7QUFBQSxRQUNmLE1BQU07QUFBQSxRQUNOLFdBQVcsTUFBTTtBQUFBLFFBQ2pCLGlCQUFpQixNQUFNO0FBQUEsUUFDdkIsS0FBSztBQUFBLE1BQ3JCLEdBQWU7QUFBQSxRQUNDLEVBQUUsS0FBSyxJQUFJO0FBQUEsVUFDUCxNQUFNLFVBQVUsTUFBTSxZQUFZO0FBQUEsUUFDdEQsQ0FBaUI7QUFBQSxNQUNqQixDQUFhO0FBQUEsSUFDTDtBQUFBLEVBQ0o7QUFDSixDQUFDO0FBRUQsU0FBUyxpQkFBaUIsTUFBTSxlQUFlO0FBQzNDLFVBQVEsU0FBUyxhQUFhO0FBQzlCLFNBQU8sZ0JBQWdCO0FBQUEsSUFDbkIsT0FBTztBQUFBLElBQ1AsTUFBTyxPQUFPLE9BQU87QUFDakIsVUFBSSxFQUFFLE9BQU0sSUFBTTtBQUNsQixZQUFNQyxPQUFNLFdBQVcsSUFBSTtBQUMzQixZQUFNLGVBQWUsQ0FBQyxhQUFXO0FBQzdCLFFBQUFBLEtBQUksUUFBUSxVQUFVO0FBQUEsTUFDMUI7QUFDQSxhQUFPO0FBQUEsUUFDSCxPQUFPQTtBQUFBLE1BQ3ZCLENBQWE7QUFDRCxhQUFPLE1BQUk7QUFDUCxlQUFPLEVBQUUsT0FBTyxZQUFZO0FBQUEsVUFDeEIsS0FBSztBQUFBLFFBQ3pCLEdBQW1CO0FBQUEsVUFDQztBQUFBLFVBQ0EsR0FBRztBQUFBLFFBQ3ZCLENBQWlCLENBQUM7QUFBQSxNQUNOO0FBQUEsSUFDSjtBQUFBLEVBQ1IsQ0FBSztBQUNMO0FBR0ssTUFBQyxPQUF1QixpQ0FBaUIsUUFBUSxjQUFjO0FBQy9ELE1BQUMsTUFBc0IsaUNBQWlCLE9BQU8sYUFBYTsiLCJ4X2dvb2dsZV9pZ25vcmVMaXN0IjpbMF19
